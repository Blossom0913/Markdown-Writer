#! https://zhuanlan.zhihu.com/p/578802594

# SICP阅读笔记

<center> 2022.10.10 
         By Blossom.
</center>

## 目录

1. Blossom本人碎碎念
2. 前言的笔记
3. Section1 构造过程抽象

---

### 一些碎碎念

- 写这篇笔记的初衷，主要是在`Github`上刨到的CS自学指南中提及这本书，然后看了`B站`上的教学视频，自知收益匪浅，于是打算写一篇笔记记录和督促自己学习这本书的过程
- 这本书及其配套的教程非常经典，在互联网上可以轻松找到电子书和视频教程，但还是在这里放几个链接方便后来人的学习吧——>[计算机程序的构造和解释](https://github.com/DeathKing/Learning-SICP)

---

### 前言

> “一台计算机就像是一把小提琴。你可以想象一个新手试了一个音符然后丢掉了它。后来他说，听起来真难听。我们已经从大众和我们的大部分计算机科学家那里反复听到这说法。他们说，计算机程序对个别具体用途而言确实是好东西，但它们太缺乏弹性。一把小提琴或者一台打字机也同样缺乏弹性，但那是在你学会了如何去使用它们之前。

>     "为什么说程序设计很容易成为一种媒介，用于表述浅浮、草率而就的思想"

- 原著Clip
  
  1. 每一个计算机程序都是现实中或者精神中的某个过程的一个模型
  2. 如果说是艺术解释了我们的梦想，那么计算机就是以程序的名义执行着它们
  3. 有些程序执行了某个精确的数学函数（例如排序），我们将这种程序称为算法。对于它的最佳行为已经有了许多认识，特别是关于两个重要的参数：执行的时间和对数据存储的需求。
  4. 在适当的时候隐藏起一些细节，通过创建抽象去控制复杂性。

- 随便写点
  
  1. SICP前言里对于程序的定义实在是醍醐灌顶，相比之下，谭浩强的C里面`程序 = 算法 + 数据结构`的定义太狭小了
  2. 过程抽象和数据抽象是控制程序复杂度的有效方式

---

### Section1 构造过程抽象

> 心智的活动，除了尽力产生各种简单的认识之外，主要表现在如下三个方面:
> 1.将若干简单的认识组合为一个复合认识，由此产生出各种复杂的认识
> 2.将两个认识放在一起对照，不管他们如何简单或者复杂，在这样做时并不将他们合二为一。由此得到他们的相互关系的认识。
> 3.将有关认识与那些在实际中和它们同在的所有其他认识隔离开，这就是抽象，所有具有普遍性的认识都是这样得到的。

- 原著Clip
  
  1. Lisp是1950s后期发明的一种记法形式，是为了能对某种特定形式的逻辑表达式（**递归方程**）的使用做推理。这一语言由`John McCarthy`设计,出自他的论文[Recursive functions of symbolic expressions and their computation by machine, Part I](https://readpaper.com/paper/2045255985)
  2. `Lisp`语言的一大特性：计算过程的`Lisp`描述（称为`过程`）本身又可以作为Lisp的数据来表示和操作
  3. 前缀表示的一个优点在于它完全适用于可能带有任意个实参的过程
  4. 我们应该把递归看作一种处理层次结构的（像树这样的对象）极强有力的技术
  5. 一个过程也就是一种模式，它描述了一个计算`过程的局部演化方式`，描述了这一过程中的每个步骤是怎么样基于前面的步骤建立起来的。在有了一个刻画计算过程的描述之后，我们当然希望能做出一些有关这一计算过程的整体或`全局`行为的论断
  6. 定义一个`不变量`，要求它在状态之间保持不变，这一技术是思考迭代算法设计问题时的一种强有力的说法。

- 随便写点
  
  1. 就像我们平时用的中文、英文一样，`程序设计语言`也不过是一种向计算机表达自己思想的方式
  2. 语法糖——用统一形式描述的东西给出的另一种表面结构，给某个`Procedure`取外号方便调用
  3. 黑箱抽象——从原问题到子问题的分解：分解中的每一个过程完成了一件可以清楚标明的工作。这使它们可以被用作定义其他过程的模块。
  4. 所有的`尾递归`都可以用`循环`来代替。

- `Fibonacci`算法的不同复杂度实现：
  
  1. ```c
      //指数复杂度实现
      int Fib(int n){
          if(n==0){return 0;}
          else if(n==1){return 1;}
          else return Fib(n - 2) + Fib(n - 1);
      }
     ```
  
  2. ```c
      //线性复杂度实现
      int Fib(int n){
          int a = 1;
          int b = 0;
          while(n > 0){
              a = a + b;
              b = a;  //Core Algorithm
              n--;
          }
          return b; 
      }
     ```
  
  3. ```c
      //对数复杂度实现
      int Fib(int n){
          int a = 1;
          int b = 0;
          int p = 0;
          int q = 1;
          while(n > 0){
              if(!n&1){ //如果是偶数
                  int tmp = p;
                  p = p*p + q*q;
                  q = 2*tmp*q + q*q;
                  n /= 2;
              }
              else{
                  a = (a + b)*q + a*p;
                  b = b*p + a*q;
                  n--;
              }
          }
          return b;
      }
     ```

        ```

- 过程也就是一类抽象，能为公共的模式命名，建立抽象，对功能强大的程序设计语言是一个必然要求
- 为了把公共模式描述为相应的概念，我们就需要构造出这样的过程，让它们以过程作为参数，或者以过程作为返回值。这类能操作过程的过程称为高阶过程。
